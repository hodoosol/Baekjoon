# 2485 가로수, 실버 4
from math import gcd                                # 최대공약수를 구하기위해 math 라이브러리 불러오기
n = int(input())                                    # 이미 심어져있는 가로수의 개수 n
trees = []                                          # 이미 심어져있는 가로수의 위치를 저장할 trees 리스트
for i in range(n) :                                 # n만큼 for문 돌리기
    trees.append(int(input()))                      # trees 리스트에 가로수의 위치 저장
# 최대공약수를 구하는 이유 ? 이미 심어져 있는 간격들의 최대공약수로
# 나머지 가로수를 심는 것이, 가로수를 최소 개수로 심고 + 모든 가로수의 간격을 같게 만들기 때문  !!
G = trees[1] - trees[0]                             # 최대공약수를 구하기 위해 두번째 나무와 첫번째 나무의 간격을 G에 저장
for j in range(2, n) :                              # 세번째 나무와 두번째 나무의 간격부터 끝까지 꺼내올 수 있는 for문
    G = gcd(G, trees[j] - trees[j - 1])             # 다음 간격으로 계속 업데이트하며 모든 나무의 간격의 최대공약수를 구한다.

answer = ((trees[-1] - trees[0]) // G) - (n - 1)   # 그렇게 구해진 최대공약수로 처음 가로수 - 끝 가로수의 길이를 나누고,
print(answer)                                      # 이미 심어져있던 가로수와 첫 가로수를 빼준 것이 심어야할 가로수의 최소이다.




